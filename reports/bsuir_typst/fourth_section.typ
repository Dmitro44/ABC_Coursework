#import "stp/stp.typ"

= Проектирование функциональных возможностей программы  

== Общая цель программы

Целью разработки программного обеспечения является создание приложения для сравнительного анализа производительности двух современных мобильных процессоров — #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") — при выполнении параллельных вычислений. Программа позволяет исследовать влияние архитектурных различий, в частности различных моделей многопоточности и организации кэш-памяти, на производительность многоядерных систем. Разработанное приложение предоставляет объективные данные о производительности каждого процессора в различных сценариях распараллеливания, что позволяет сделать обоснованные выводы об эффективности каждой архитектуры.

== Теоретические сведения о алгоритме быстрого преобразования Фурье

Быстрое преобразование Фурье (БПФ) — это алгоритм, который вычисляет дискретное преобразование Фурье (ДПФ) последовательности за время $O(n log n)$ вместо наивного подхода $O(n^2)$ @FFTExplanation. Дискретное преобразование Фурье преобразует последовательность комплексных чисел $x_0, x_1, ..., x_{n-1}$ в последовательность $X_0, X_1, ..., X_{n-1}$ согласно формуле:

$ X_k = sum_(j=0)^(n-1) x_j e^(frac(-2 pi i j k, n)) $

#stp.explanation(
  [$X_k$], [--],
  [спектральный коэффициент преобразования Фурье для частоты $k$],
  [$x_j$], [--],
  [исходный элемент последовательности с индексом $j$],
  [$n$], [--],
  [длина последовательности],
  [$k$], [--],
  [индекс спектрального компонента, где $k = 0, 1, ..., n-1$],
  [$i$], [--],
  [мнимая единица],
)

Существует два основных подхода к реализации алгоритма #emph("БПФ"): рекурсивный и итеративный. Рекурсивный подход, известный как алгоритм Кули-Тьюки, основан на разложении исходной последовательности на две подпоследовательности (чётные и нечётные индексы), что приводит к следующему соотношению:

$ X_k = sum_(j=0)^(frac(n, 2)-1) x_(2j) e^(frac(-4 pi i j k, n)) + e^(frac(-2 pi i k, n)) sum_(j=0)^(frac(n, 2)-1) x_(2j+1) e^(frac(-4 pi i j k, n)) $

#stp.explanation(
  [$X_k$], [--], [спектральный коэффициент преобразования Фурье],
  [$x_(2j)$], [--], [элементы последовательности с чётными индексами],
  [$x_(2j+1)$], [--], [элементы последовательности с нечётными индексами],
  [$n\/2$], [--], [размер подпоследовательностей],
  [$e^(-2 pi i k \/ n)$], [--], [поворачивающий множитель (#emph("twiddle factor"))],
)

Однако в данной работе использован #emph("итеративный подход"), который реализует тот же принцип разложения Кули-Тьюки, но без рекурсивных вызовов. Итеративный алгоритм начинает с перестановки входных данных согласно битовой инверсии индексов, а затем выполняет логарифмическое количество проходов ($log_2(n)$ проходов). На каждом проходе применяются бабочковые операции (#emph("butterfly operation")) с различными поворачивающими множителями $W$. Такой подход избегает рекурсивных вызовов, снижает издержки на управление стеком вызовов и повышает локальность доступа к данным, что способствует лучшему использованию кэш-памяти процессора.

Ключевой операцией в итеративном алгоритме является бабочковая операция, в которой два входных элемента $a$ и $b$ комбинируются с поворачивающим множителем $W$ по следующей схеме: первый выходной элемент равен $a + W b$, а второй равен $a - W b$. Эта операция выполняется миллионы раз во время вычисления и является основной нагрузкой на процессор. Такая структура операций позволяет алгоритму содержать на каждом проходе операции с независимыми данными, что особенно хорошо подходит для параллельного выполнения на многоядерных архитектурах.

Благодаря своему широкому применению в обработке сигналов, анализе изображений и решении дифференциальных уравнений, эффективность реализации БПФ напрямую влияет на производительность многих научных и инженерных приложений. Именно поэтому БПФ выбран в качестве тестовой нагрузки: алгоритм чувствителен к архитектурным особенностям процессора, таким как размер кэш-памяти, ширина пропускной способности памяти и эффективность параллелизма, что позволяет провести глубокий анализ различий между архитектурами #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H").

== Описание функциональных возможностей

Разработанное приложение предоставляет комплексный набор инструментов для проведения детального анализа производительности многоядерных процессоров при выполнении алгоритма быстрого преобразования Фурье. Программа позволяет исследовать влияние архитектурных различий на эффективность параллельных вычислений и выявить закономерности масштабируемости производительности в зависимости от количества активных рабочих потоков.

Приложение реализует следующий функциональный набор:

+ #[Генерация входных данных. Создается синтетический набор комплексных чисел размером $2^n$, где $n$ варьируется в диапазоне от 5 до 24, что позволяет исследовать производительность на различных масштабах данных от нескольких килобайт до нескольких мегабайт.]

+ #[Реализация итеративного алгоритма БПФ. Вычисление быстрого преобразования Фурье выполняется с использованием итеративного подхода Кули-Тьюки, который избегает рекурсивных вызовов и обеспечивает лучшее использование кэш-памяти процессора.]

+ #[Многопоточное выполнение. Программа поддерживает произвольное количество рабочих потоков от 1 до максимально доступного на платформе, с возможностью динамического масштабирования параллелизма и анализа зависимости производительности от степени параллелизации.]

+ #[Привязка потоков к ядрам. Осуществляется управление сродством потоков к физическим ядрам процессора через системный вызов #emph("sched_setaffinity"), что исключает влияние планировщика операционной системы и обеспечивает воспроизводимость и детерминированность результатов.]

+ #[Изолированное тестирование ядер. На архитектуре #emph("Intel Core i5-12450H") реализована возможность раздельного анализа производительных (P-cores) и энергоэффективных (E-cores) ядер без их взаимного влияния, что позволяет оценить архитектурные различия.]

+ #[Точное измерение времени. Для регистрации времени выполнения используются высокоточные системные часы с разрешением в микросекунды через библиотеку #emph("std::chrono"), что обеспечивает достоверность и точность полученных метрик.]

+ #[Сохранение результатов. Результаты измерений сохраняются в формате #emph("CSV"), содержащем информацию о количестве потоков, размере входных данных, времени выполнения и вычисленной пропускной способности, что упрощает последующий анализ и визуализацию данных.]

+ #[Верификация корректности. Проводится тестирование правильности вычисления преобразования Фурье через сравнение результатов итеративного алгоритма с эталонной реализацией, что обеспечивает надёжность измеряемых результатов.]

Таким образом, разработанное приложение представляет собой полнофункциональный инструмент для объективного сравнения архитектур #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") в контексте вычислительно интенсивных задач, обеспечивающий надёжность и воспроизводимость результатов.

// Разработанное приложение предоставляет комплексный набор инструментов для проведения детального анализа производительности многоядерных процессоров при выполнении алгоритма быстрого преобразования Фурье. Программа позволяет исследовать влияние архитектурных различий на эффективность параллельных вычислений и выявить закономерности масштабируемости производительности в зависимости от количества активных рабочих потоков.
//
// Основной функциональностью приложения является вычисление итеративного алгоритма быстрого преобразования Фурье с возможностью гибкого управления параметрами выполнения. Программа поддерживает многопоточное выполнение с произвольным количеством рабочих потоков от 1 до максимально доступного на платформе. Критической особенностью реализации является привязка каждого потока к конкретному физическому ядру процессора через механизм #emph("CPU affinity"), что исключает влияние системного планировщика и обеспечивает воспроизводимость результатов измерений.
//
// На архитектуре #emph("Intel Core i5-12450H") приложение предоставляет возможность изолированного тестирования производительных и энергоэффективных ядер отдельно, что позволяет оценить их характеристики без влияния друг на друга. Измерение производительности выполняется с высокой точностью с использованием системных часов разрешением в микросекунды через библиотеку #emph("std::chrono"). Полученные результаты выводятся в структурированном формате, пригодном для последующего анализа и построения графиков зависимости производительности от числа потоков.
//
// Таким образом, разработанное приложение представляет собой полнофункциональный инструмент для объективного сравнения архитектур #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") в контексте вычислительно интенсивных задач.
