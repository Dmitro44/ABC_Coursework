#import "stp/stp.typ"

= Проектирование функциональных возможностей программы  

== Общая цель программы

Целью разработки программного обеспечения является создание приложения для сравнительного анализа производительности двух современных мобильных процессоров — #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") — при выполнении параллельных вычислений. Программа позволяет исследовать влияние архитектурных различий, в частности различных моделей многопоточности и организации кэш-памяти, на производительность многоядерных систем. Разработанное приложение предоставляет объективные данные о производительности каждого процессора в различных сценариях распараллеливания, что позволяет сделать обоснованные выводы об эффективности каждой архитектуры.

== Теоретические сведения о алгоритме быстрого преобразования Фурье

Быстрое преобразование Фурье (БПФ) — это алгоритм, который вычисляет дискретное преобразование Фурье (ДПФ) последовательности за время $O(n log n)$ вместо наивного подхода $O(n^2)$ @FFTExplanation. Дискретное преобразование Фурье преобразует последовательность комплексных чисел $x_0, x_1, ..., x_{n-1}$ в последовательность $X_0, X_1, ..., X_{n-1}$ согласно формуле:

$ X_k = sum_(j=0)^(n-1) x_j e^(frac(-2 pi i j k, n)), $

#stp.explanation(
  [$X_k$], [--],
  [спектральный коэффициент преобразования Фурье для частоты $k$;],
  [$x_j$], [--],
  [исходный элемент последовательности с индексом $j$;],
  [$n$], [--],
  [длина последовательности;],
  [$k$], [--],
  [индекс спектрального компонента, где $k = 0, 1, ..., n-1$;],
  [$i$], [--],
  [мнимая единица.],
)

Существует два основных подхода к реализации алгоритма #emph("БПФ"): рекурсивный и итеративный. Рекурсивный подход, известный как алгоритм Кули-Тьюки, основан на разложении исходной последовательности на две подпоследовательности (чётные и нечётные индексы), что приводит к следующему соотношению:

$ X_k = sum_(j=0)^(frac(n, 2)-1) x_(2j) e^(frac(-4 pi i j k, n)) + e^(frac(-2 pi i k, n)) sum_(j=0)^(frac(n, 2)-1) x_(2j+1) e^(frac(-4 pi i j k, n)), $

#stp.explanation(
  [$X_k$], [--], [спектральный коэффициент преобразования Фурье;],
  [$x_(2j)$], [--], [элементы последовательности с чётными индексами;],
  [$x_(2j+1)$], [--], [элементы последовательности с нечётными индексами;],
  [$n\/2$], [--], [размер подпоследовательностей;],
  [$e^(-2 pi i k \/ n)$], [--], [поворачивающий множитель (#emph("twiddle factor")).],
)

Однако в данной работе использован итеративный подход, который реализует тот же принцип разложения Кули-Тьюки, но без рекурсивных вызовов. Итеративный алгоритм начинает с перестановки входных данных согласно битовой инверсии индексов, а затем выполняет логарифмическое количество проходов ($log_2(n)$ проходов). На каждом проходе применяются бабочковые операции (#emph("butterfly operation")) с различными поворачивающими множителями $W$. Такой подход избегает рекурсивных вызовов, снижает издержки на управление стеком вызовов и повышает локальность доступа к данным, что способствует лучшему использованию кэш-памяти процессора.

Ключевой операцией в итеративном алгоритме является бабочковая операция, в которой два входных элемента $a$ и $b$ комбинируются с поворачивающим множителем $W$ по следующей схеме: первый выходной элемент равен $a + W b$, а второй равен $a - W b$. Эта операция выполняется миллионы раз во время вычисления и является основной нагрузкой на процессор. Такая структура операций позволяет алгоритму содержать на каждом проходе операции с независимыми данными, что особенно хорошо подходит для параллельного выполнения на многоядерных архитектурах.

Благодаря своему широкому применению в обработке сигналов, анализе изображений и решении дифференциальных уравнений, эффективность реализации БПФ напрямую влияет на производительность многих научных и инженерных приложений. Именно поэтому БПФ выбран в качестве тестовой нагрузки: алгоритм чувствителен к архитектурным особенностям процессора, таким как размер кэш-памяти, ширина пропускной способности памяти и эффективность параллелизма, что позволяет провести глубокий анализ различий между архитектурами #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H").

== Описание функциональных возможностей

Разработанное приложение предоставляет комплексный набор инструментов для проведения детального анализа производительности многоядерных процессоров при выполнении алгоритма быстрого преобразования Фурье. Программа позволяет исследовать влияние архитектурных различий на эффективность параллельных вычислений и выявить закономерности масштабируемости производительности в зависимости от количества активных рабочих потоков.

Приложение реализует следующий функциональный набор:

+ #[Генерация входных данных. Создается синтетический набор комплексных чисел размером $2^n$, где $n$ варьируется в диапазоне от 5 до 24, что позволяет исследовать производительность на различных масштабах данных от нескольких килобайт до нескольких мегабайт.]

+ #[Реализация итеративного алгоритма БПФ. Вычисление быстрого преобразования Фурье выполняется с использованием итеративного подхода Кули-Тьюки, который избегает рекурсивных вызовов и обеспечивает лучшее использование кэш-памяти процессора.]

+ #[Многопоточное выполнение. Программа поддерживает произвольное количество рабочих потоков от 1 до максимально доступного на платформе, с возможностью динамического масштабирования параллелизма и анализа зависимости производительности от степени параллелизации.]

+ #[Привязка потоков к ядрам. Осуществляется управление сродством потоков к физическим ядрам процессора через системный вызов #emph("sched_setaffinity"), что исключает влияние планировщика операционной системы и обеспечивает воспроизводимость и детерминированность результатов.]

+ #[Изолированное тестирование ядер. На архитектуре #emph("Intel Core i5-12450H") реализована возможность раздельного анализа производительных (P-cores) и энергоэффективных (E-cores) ядер без их взаимного влияния, что позволяет оценить архитектурные различия.]

+ #[Точное измерение времени. Для регистрации времени выполнения используются высокоточные системные часы с разрешением в микросекунды через библиотеку #emph("std::chrono"), что обеспечивает достоверность и точность полученных метрик.]

+ #[Сохранение результатов. Результаты измерений сохраняются в формате #emph("CSV"), содержащем информацию о количестве потоков, размере входных данных, времени выполнения и вычисленной пропускной способности, что упрощает последующий анализ и визуализацию данных.]

+ #[Верификация корректности. Проводится тестирование правильности вычисления преобразования Фурье через сравнение результатов итеративного алгоритма с эталонной реализацией, что обеспечивает надёжность измеряемых результатов.]

Таким образом, разработанное приложение представляет собой полнофункциональный инструмент для объективного сравнения архитектур #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") в контексте вычислительно интенсивных задач, обеспечивающий надёжность и воспроизводимость результатов.

== Описание функциональной схемы алгоритма 

Функциональная схема алгоритма БПФ представлена в приложении В и отражает последовательность основных этапов работы программы. Алгоритм состоит из пяти функциональных блоков, каждый из которых выполняет определённую задачу в процессе тестирования производительности.

Работа программы начинается с блока инициализации параметров алгоритма. На этом этапе выполняется разбор аргументов командной строки, определяется размер входных данных (степень двойки n ), количество рабочих потоков и режим привязки к ядрам процессора. Также инициализируются структуры данных для хранения результатов измерений и настраиваются параметры многопоточной среды выполнения.

Следующим этапом является выбор режима выполнения. Программа определяет, какой сценарий тестирования будет использован: последовательное выполнение на одном ядре либо параллельное выполнение с заданным количеством потоков. На основе выбранного режима настраивается политика распределения потоков по физическим ядрам процессора с учётом архитектурных особенностей целевой платформы.

Блок генерации тестовых значений отвечает за создание входного массива комплексных чисел. Формируется синтетический набор данных размером $2 n$ элементов, где каждый элемент представляет собой комплексное число с действительной и мнимой частями. Генерация выполняется с использованием детерминированного алгоритма, что обеспечивает воспроизводимость результатов при повторных запусках программы.

Центральным этапом является выполнение алгоритмов быстрого преобразования Фурье. В этом блоке реализуется итеративный алгоритм Кули-Тьюки с распараллеливанием бабочковых операций между рабочими потоками. Каждый поток обрабатывает независимый диапазон индексов, а синхронизация между проходами алгоритма осуществляется с помощью барьеров. Одновременно с вычислениями производится измерение времени выполнения с использованием высокоточных системных часов.

Завершающий блок выполняет сохранение результатов и освобождение ресурсов. Результаты измерений, включающие время выполнения, количество использованных потоков и размер обработанных данных, записываются в файл формата CSV. После этого освобождается выделенная память, завершаются рабочие потоки и программа корректно завершает своё выполнение.


== Описание блок схемы алгоритма 

Блок-схема алгоритма программного средства представлена в приложении Г и состоит из трёх взаимосвязанных частей: главного алгоритма, алгоритма однопоточного БПФ и алгоритма многопоточного БПФ.

Главный алгоритм определяет общую логику работы программы. После запуска выполняется получение набора входных данных, представляющего собой массив комплексных чисел заданного размера. Далее осуществляется проверка выбранного режима вычислений. Если выбран однопоточный режим, управление передаётся соответствующей подпрограмме. В случае многопоточного режима предварительно определяется количество потоков для вычислений, после чего вызывается подпрограмма многопоточного БПФ. После завершения вычислений результаты тестирования сохраняются в файл формата #emph("CSV").

Подпрограмма однопоточного алгоритма БПФ реализует итеративный подход Кули-Тьюки. Внешний цикл обеспечивает проход по заданным размерам входных данных для проведения серии измерений. Для каждого размера сначала выполняется бит-реверсивная перестановка элементов массива, которая подготавливает данные для последующих вычислений. Затем начинается основной вычислительный процесс, организованный в виде трёх вложенных циклов. Внешний цикл проходит по стадиям вычислений, количество которых равно $l o g _2(n)$ . На каждой стадии определяется размер групп, после чего выполняется проход по всем группам в массиве. Внутренний цикл обрабатывает пары элементов внутри каждой группы, выполняя для них вычисление поворотного множителя и операцию «бабочка», которая заключается в вычислении суммы и разности двух элементов с учётом поворотного множителя.

Подпрограмма многопоточного алгоритма БПФ расширяет однопоточную версию механизмами параллельного выполнения. После входа в цикл по размерам данных создаётся и запускается заданное количество рабочих потоков. Бит-реверсивная перестановка выполняется параллельно, после чего происходит синхронизация потоков для обеспечения корректности последующих вычислений. На каждой стадии алгоритма применяется адаптивная стратегия распараллеливания. Если количество групп на текущей стадии больше или равно количеству потоков, используется крупнозернистый параллелизм — каждый поток обрабатывает свою часть групп независимо. В противном случае применяется мелкозернистый параллелизм, при котором потоки совместно обрабатывают пары элементов внутри одной группы. Такой подход обеспечивает эффективную загрузку всех потоков на любой стадии вычислений. После завершения каждой стадии выполняется синхронизация потоков с помощью барьера, что гарантирует завершение всех операций перед переходом к следующей стадии. По окончании всех стадий рабочие потоки завершают свою работу.

