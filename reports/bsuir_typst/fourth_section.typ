#import "stp/stp.typ"

= Проектирование функциональных возможностей программы  

== Общая цель программы

Целью разработки программного обеспечения является создание приложения для сравнительного анализа производительности двух современных мобильных процессоров — #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") — при выполнении параллельных вычислений. Программа позволяет исследовать влияние архитектурных различий, в частности различных моделей многопоточности и организации кэш-памяти, на производительность многоядерных систем. Разработанное приложение предоставляет объективные данные о производительности каждого процессора в различных сценариях распараллеливания, что позволяет сделать обоснованные выводы об эффективности каждой архитектуры.

== Теоретические сведения о алгоритме быстрого преобразования Фурье

Быстрое преобразование Фурье (БПФ) — это алгоритм, который вычисляет дискретное преобразование Фурье (ДПФ) последовательности за время $O(n log n)$ вместо наивного подхода $O(n^2)$ @FFTExplanation. Дискретное преобразование Фурье преобразует последовательность комплексных чисел $x_0, x_1, ..., x_{n-1}$ в последовательность $X_0, X_1, ..., X_{n-1}$ согласно формуле:

$ X_k = sum_(j=0)^(n-1) x_j e^(frac(-2 pi i j k, n)) $

#stp.explanation(
  [$X_k$], [--],
  [спектральный коэффициент преобразования Фурье для частоты $k$],
  [$x_j$], [--],
  [исходный элемент последовательности с индексом $j$],
  [$n$], [--],
  [длина последовательности],
  [$k$], [--],
  [индекс спектрального компонента, где $k = 0, 1, ..., n-1$],
  [$i$], [--],
  [мнимая единица],
)

Существует два основных подхода к реализации алгоритма #emph("БПФ"): рекурсивный и итеративный. Оба подхода достигают вычислительной сложности $O(n log n)$, однако итеративный подход, использованный в данной работе, более эффективен с точки зрения практического применения. Основной принцип алгоритма Кули-Тьюки заключается в разложении исходной последовательности на две подпоследовательности (чётные и нечётные индексы), что приводит к следующему соотношению:

$ X_k = sum_(j=0)^(frac(n, 2)-1) x_(2j) e^(frac(-4 pi i j k, n)) + e^(frac(-2 pi i k, n)) sum_(j=0)^(frac(n, 2)-1) x_(2j+1) e^(frac(-4 pi i j k, n)) $

#stp.explanation(
  [$X_k$], [--], [спектральный коэффициент преобразования Фурье],
  [$x_(2j)$], [--], [элементы последовательности с чётными индексами],
  [$x_(2j+1)$], [--], [элементы последовательности с нечётными индексами],
  [$n\/2$], [--], [размер подпоследовательностей],
  [$e^(-2 pi i k \/ n)$], [--], [поворачивающий множитель (#emph("twiddle factor"))],
)

Итеративный алгоритм применяет это разложение без рекурсивных вызовов, что снижает издержки на управление стеком вызовов и повышает локальность доступа к данным, способствуя лучшему использованию кэш-памяти процессора.

Ключевой операцией в алгоритме является так называемая "бабочковая" операция (#emph("butterfly operation")), которая комбинирует два комплексных числа с использованием экспоненциальных коэффициентов. Именно эта операция выполняется миллионы раз во время вычисления и является основной нагрузкой на процессор. Благодаря своему широкому применению в обработке сигналов, анализе изображений и решении дифференциальных уравнений, эффективность реализации БПФ напрямую влияет на производительность многих научных и инженерных приложений.

== Описание функциональных возможностей

Разработанное приложение предоставляет комплексный набор инструментов для проведения детального анализа производительности многоядерных процессоров при выполнении алгоритма быстрого преобразования Фурье. Программа позволяет исследовать влияние архитектурных различий на эффективность параллельных вычислений и выявить закономерности масштабируемости производительности в зависимости от количества активных рабочих потоков.

Основной функциональностью приложения является вычисление итеративного алгоритма быстрого преобразования Фурье с возможностью гибкого управления параметрами выполнения. Программа поддерживает многопоточное выполнение с произвольным количеством рабочих потоков от 1 до максимально доступного на платформе. Критической особенностью реализации является привязка каждого потока к конкретному физическому ядру процессора через механизм #emph("CPU affinity"), что исключает влияние системного планировщика и обеспечивает воспроизводимость результатов измерений.

На архитектуре #emph("Intel Core i5-12450H") приложение предоставляет возможность изолированного тестирования производительных и энергоэффективных ядер отдельно, что позволяет оценить их характеристики без влияния друг на друга. Измерение производительности выполняется с высокой точностью с использованием системных часов разрешением в микросекунды через библиотеку #emph("std::chrono"). Полученные результаты выводятся в структурированном формате, пригодном для последующего анализа и построения графиков зависимости производительности от числа потоков.

Таким образом, разработанное приложение представляет собой полнофункциональный инструмент для объективного сравнения архитектур #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") в контексте вычислительно интенсивных задач.
