#import "stp/stp.typ"

= Сравнение производительности процессоров

== Общая структура программы

Программа представляет собой систему для сравнительного анализа производительности итеративного алгоритма быстрого преобразования Фурье (БПФ) по основанию 2, реализованную для выполнения вычислений как на центральном (#emph("CPU")), так и на графическом (#emph("GPU")) процессоре. Архитектура проекта является модульной, что обеспечивается системой сборки #emph("CMake"), и разделена на несколько независимых исполняемых файлов: основной бенчмарк для #emph("CPU") и бенчмарк для #emph("GPU") на базе #emph("OpenCL").

Центральным компонентом является класс #emph("benchmark"), инкапсулирующий логику тестирования на #emph("CPU"). Он содержит реализации как однопоточной (#emph("fft_iterative")), так и многопоточной (#emph("fft_iterative_multithreaded")) версий алгоритма. Многопоточная реализация построена с использованием нативных средств языка: для создания параллельных потоков вычислений применяются #emph("std::thread"), а для их синхронизации между стадиями БПФ — #emph("std::barrier").

Тестирование производительности выполняется на прогрессивном наборе из 21 размера входных данных, от 32 до 33,554,432 элементов. Для каждого запуска генерируется массив комплексных чисел (#emph("std::vector<std::complex<double>>")) с использованием генератора псевдослучайных чисел #emph("std::mt19937"). Для обеспечения полной воспроизводимости тестов генератор инициализируется фиксированным значением. Точность измерений времени выполнения гарантируется использованием высокоточных часов #emph("std::chrono::high_resolution_clock").

Модуль #emph("GPU")-вычислений представляет собой отдельную программу, использующую технологию #emph("OpenCL") для выполнения БПФ на графическом процессоре. Основная логика вычислений вынесена в ядро #emph("fft_kernel.cl"), которое выполняет одну стадию преобразования. Управляющий код на #box[#emph("C++")] отвечает за инициализацию #emph("OpenCL"), передачу данных на устройство, последовательный вызов ядра для каждой стадии алгоритма и сбор результатов.

Управление режимами работы программы осуществляется через аргументы командной строки. Флаги #emph("--mode") и #emph("--threads") позволяют запускать однопоточную или многопоточную версию с заданным количеством потоков. Результаты каждого теста, содержащие размер входных данных и время выполнения в миллисекундах, сохраняются в структурированный #emph("CSV")-файл для последующего анализа и построения графиков.


== Подготовка к тестированию

Для проведения сравнительного анализа производительности процессоров #emph("AMD Ryzen 7 5800H") и #emph("Intel Core i5-12450H") была сформирована стандартизированная тестовая среда. В качестве входных данных для каждого запуска генерировался массив комплексных чисел заданного размера. Для обеспечения воспроизводимости результатов генерация случайных чисел выполнялась с фиксированным начальным значением.

Ключевым аспектом подготовки стало управление средой исполнения. Тесты проводились в нескольких конфигурациях: для одного ядра, а также для 4 и 8 физических ядер. Каждый из этих сценариев был выполнен дважды: с включенной и принудительно отключенной технологией одновременной многопоточности (#emph("SMT") для #emph("AMD"), #emph("Hyper-Threading") для #emph("Intel")).

Чтобы гарантировать выполнение потоков на строго определенных физических ядрах и исключить влияние системного планировщика, использовалась утилита #emph("taskset"). Стратегия привязки потоков (#emph("CPU affinity")) зависела от режима #emph("SMT/HT"). При включенной технологии многопоточности потоки привязывались к последовательному набору логических процессоров (0, 1, 2, ...). При отключенной технологии #emph("SMT/HT") применялась специальная стратегия для работы с физическими ядрами: для процессора #emph("AMD") потоки привязывались к ядрам с четными номерами (0, 2, 4, ...), а для гибридной архитектуры #emph("Intel") потоки сначала занимали все доступные производительные #emph("P")-ядра (0, 2, 4, 6), и только после их исчерпания назначались на энергоэффективные #emph("E")-ядра (8, 9, 10, 11).

Для сбора данных о производительности использовался набор стандартных утилит. Основные аппаратные метрики собирались с помощью инструмента #emph("perf stat") по следующим событиям: #emph("cycles"), #emph("instructions"), #emph("cache-references"), #emph("cache-misses"), #emph("branch-instructions") и #emph("branch-misses"). Эти данные позволили в дальнейшем рассчитать такие показатели, как #emph("IPC") (инструкций за такт) и процент промахов. Одновременно с этим, утилита #emph("mpstat") использовалась для фонового мониторинга и сбора данных о нагрузке на каждое логическое ядро процессора, что позволяло верифицировать корректность распределения нагрузки в ходе теста.



== Результаты тестирования с включенным SMT/Hyper-Threading

Анализ результатов тестирования процессора #emph("AMD Ryzen 7 5800H") позволяет выявить характерные закономерности масштабирования производительности при параллельном выполнении алгоритма быстрого преобразования Фурье. На малых размерах входных данных однопоточное выполнение демонстрирует значительное преимущество перед многопоточными конфигурациями. Это объясняется природой накладных расходов на организацию параллельных вычислений: создание потоков, распределение работы и синхронизация на барьерах требуют фиксированного времени, которое не зависит от объёма полезных вычислений. 

По мере увеличения размера входного массива соотношение между полезными вычислениями и накладными расходами изменяется в пользу первых. Использование четырёх ядер начинает приносить выигрыш раньше, чем использование восьми, поскольку меньшее количество потоков требует меньших затрат на синхронизацию. На очень больших размерах данных, превышающих объём кэш-памяти третьего уровня, разница между четырьмя и восемью ядрами становится минимальной, что свидетельствует о достижении предела пропускной способности подсистемы памяти. Результаты измерений времени выполнения представлены в таблице @smt_on_amd_raw.

#figure(
  caption:[Замеры времени выполнения на #emph("AMD Ryzen 7 5800H")],
  // table(
  //   columns:(19%, 27%, 27%, 27%),
  //   rows: auto,
  //   align: center,
  kind: table,
  stp.longtable(
    columns:(19%, 27%, 27%, 1fr),
    rows: (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Размер],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),
    // [Размер], [Одно ядро], [4 ядра], [8 ядер],
    [32], [0.009858], [0.482569], [1.0882],
    [64], [0.001393], [0.378853], [0.564479],
    [128], [0.002305], [0.317166], [0.517923],
    [256], [0.004418], [0.307974], [0.542613],
    [512], [0.009889], [0.347999], [0.557287],
    [1024], [0.034955], [0.378583], [0.650579],
    [2048], [0.040055], [0.330224], [0.570899],
    [4096], [0.104135], [0.321323], [0.591723],
    [8192], [0.189985], [0.374917], [0.713431],
    [16384], [0.412492], [0.434351], [0.710907],
    [32768], [0.976186], [0.571204], [0.721745],
    [65536], [2.18888], [0.89526], [0.960985],
    [131072], [4.65683], [1.38313], [2.19718],
    [262144], [9.88293], [2.52728], [2.03694],
    [524288], [20.8727], [4.38266], [3.32503],
    [1048576], [47.7608], [10.7941], [7.11852],
    [2097152], [155.939], [77.1275], [70.2616],
    [4194304], [365.071], [188.538], [182.289],
    [8388608], [698.916], [437.435], [437.477],
    [16777216], [1427.81], [918.334], [895.01],
    [33554432], [3054.66], [1973.62], [1925.17],
  ),
) <smt_on_amd_raw>

Метрики производительности раскрывают внутренние причины наблюдаемого поведения. Показатель #emph("IPC") существенно снижается при переходе к многопоточному режиму, что связано с возросшей нагрузкой на подсистему памяти и работой протокола когерентности кэшей. Процент промахов кэша демонстрирует резкий рост при увеличении количества активных ядер: все ядра разделяют общий кэш #emph("L3"), что приводит к взаимному вытеснению данных. Низкий процент промахов ветвлений свидетельствует о предсказуемой структуре алгоритма БПФ. Ключевые метрики производительности, полученные с помощью #emph("perf"), сведены в таблицу @smt_on_amd_perf.

#figure(
  caption:[Замеры метрик на #emph("AMD Ryzen 7 5800H")],
  kind: table,
  stp.longtable(
    columns:(26%, 1fr, 1fr, 1fr),
    rows:  (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Метрика],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),
 
  // table(
  //   columns:(26%, 1fr, 1fr, 1fr),
  //   rows: (2.5em, auto),
  //   align: center + horizon,
  //   [Метрика], [Одно ядро], [4 ядра], [8 ядер],
    [IPC], [1.62], [0.37], [0.21],
    [Промахи кэша (%)], [5.98], [36.49], [39.39],
    [Промахи ветвлений (%)], [0.13], [0.14], [0.15],
  ),
) <smt_on_amd_perf>

Результаты тестирования процессора #emph("Intel Core i5-12450H") демонстрируют существенно отличающуюся картину, обусловленную гибридной архитектурой #emph("Alder Lake") На малых размерах данных Intel показывает схожее с #emph("AMD") поведение, однако на больших объёмах демонстрирует значительно лучшую масштабируемость — при максимальном размере входного массива восьмиядерная конфигурация #emph("Intel") опережает аналогичную конфигурацию #emph("AMD") более чем в два раза. 

На некоторых промежуточных размерах данных конфигурация с четырьмя ядрами показывает лучшие результаты, чем с восемью.  Это объясняется тем, что при использовании четырёх потоков все они размещаются на производительных #emph("P") ядрах, тогда как при восьми потоках часть попадает на менее производительные #emph("E") ядра, замедляя общее выполнение из-за ожидания на барьерах синхронизации. Детальные замеры времени выполнения для процессора #emph("Intel") приведены в таблице @smt_on_intel_raw.

#figure(
  caption:[Замеры времени выполнения на #emph("Intel Core i5-12450H")],
  // table(
  //   columns:(19%, 27%, 27%, 27%),
  //   rows: (2.5em, auto), //(4em, auto)
  //   align: center + horizon,
  //   [Размер], [Одно ядро], [4 ядра], [8 ядер],
  kind: table,
  stp.longtable(
    columns:(19%, 27%, 27%, 1fr),
    rows:  (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Размер],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),
    [32], [0.010597], [0.491682], [1.25722],
    [64], [0.002319], [0.256993], [1.03671],
    [128], [0.003945], [0.225747], [0.833765],
    [256], [0.007881], [0.255611], [0.715128],
    [512], [0.016516], [0.315792], [0.599665],
    [1024], [0.035551], [0.342733], [0.524364],
    [2048], [0.081465], [0.39702], [0.700515],
    [4096], [0.184372], [0.409595], [0.604209],
    [8192], [0.380837], [0.462682], [0.603044],
    [16384], [0.687353], [0.551071], [0.728383],
    [32768], [1.08981], [0.652562], [0.953188],
    [65536], [3.06556], [0.940648], [1.66175],
    [131072], [4.48471], [2.14488], [4.0922],
    [262144], [9.49335], [3.1405], [5.66165],
    table.hline(stroke:none),
    [524288], [21.2841], [6.81683], [11.6393],
    [1048576], [60.7808], [15.9238], [16.1062],
    [2097152], [140.678], [43.0497], [40.349],
    [4194304], [292.681], [101.034], [85.3587],
    [8388608], [618.562], [208.171], [175.443],
    [16777216], [1274.66], [445.21], [377.736],
    [33554432], [2630.61], [909.939], [783.953],
  ),
) <smt_on_intel_raw>

Метрики #emph("Intel") представлены с разделением на #emph("P") ядра и #emph("E") ядра.  Производительные ядра демонстрируют исключительно высокий #emph("IPC"), значительно превосходящий результаты #emph("AMD"), что свидетельствует о более широких возможностях суперскалярного выполнения в микроархитектуре #emph("Golden Cove"). Энергоэффективные ядра показывают существенно более скромные результаты, соответствующие их проектному назначению — оптимизации для фоновых задач с минимальным энергопотреблением.

Высокий процент промахов кэша на #emph("Intel") по сравнению с #emph("AMD") может объясняться различиями в методиках подсчёта событий производительности между архитектурами, иной организацией кэш-иерархии, а также агрессивным механизмом предвыборки данных. Аномальный скачок промахов ветвлений на #emph("E") ядрах указывает на особенности предсказателя ветвлений в микроархитектуре #emph("Gracemont"). Сводные данные по метрикам производительности для #emph("P") и #emph("E") ядер представлены в таблице @smt_on_intel_perf.

#figure(
  caption:[Замеры метрик на #emph("Intel Core i5-12450H")],
  table(
    columns:(26%, 1fr, 1fr, 1fr),
    rows: (2.5em, auto),
    align: center + horizon,
    [Метрика], [Одно ядро], [4 ядра], [8 ядер],
    [IPC], [8.01 / 2.45], [3.43 / 0.32], [4.48 / 0.81],
    [Промахи кэша (%)], [75.65 / 68.59], [44.40 / 61.93], [49.53 / 62.25],
    [Промахи ветвлений (%)], [0.10 / 1.09], [0.14 / 8.31], [0.13 / 0.16],
  ),
) <smt_on_intel_perf>

Сравнение результатов двух процессоров при включенных технологиях многопоточности выявляет ряд закономерностей. В однопоточном режиме #emph("AMD") демонстрирует преимущество на малых и средних размерах данных благодаря меньшим накладным расходам, однако на больших массивах #emph("Intel") показывает сопоставимые или лучшие результаты. При использовании четырёх ядер процессоры демонстрируют схожую производительность на малых данных, но #emph("Intel") значительно опережает #emph("AMD") на больших размерах. Наиболее существенное различие наблюдается в восьмиядерной конфигурации: #emph("Intel") превосходит #emph("AMD") более чем вдвое на максимальных размерах массивов, что объясняется эффективным использованием #emph("Hyper-Threading") на производительных ядрах.  При этом #emph("AMD") демонстрирует значительно лучшую эффективность работы с кэш-памятью — процент промахов кэша на #emph("AMD") в несколько раз ниже, чем на #emph("Intel"), что свидетельствует о более оптимальной организации подсистемы памяти архитектуры #emph("Zen 3").

== Результаты тестирования с выключенным SMT/Hyper-Threading

// Технологии SMT и Hyper-Threading позволяют каждому физическому ядру одновременно выполнять инструкции из двух независимых потоков за счёт дублирования архитектурного состояния при сохранении общих исполнительных устройств. Для вычислительно интенсивных задач, таких как алгоритм БПФ, отключение этих технологий позволяет оценить чистую производительность физических ядер без конкуренции за ресурсы. 

Результаты AMD Ryzen 7 5800H без SMT демонстрируют улучшение однопоточной производительности на малых размерах данных — при отключенном SMT исключается интерференция с фоновыми задачами, которые планировщик мог размещать на том же физическом ядре. Многопоточная производительность изменяется неоднозначно: на средних размерах наблюдается улучшение, тогда как на очень больших результаты остаются сопоставимыми, что подтверждает гипотезу об ограничении пропускной способностью памяти. Результаты измерений времени выполнения с отключенной технологией #emph("SMT") представлены в таблице @smt_off_amd_raw.


#figure(
  caption:[Замеры времени выполнения на #emph("AMD Ryzen 7 5800H")],
  // table(
  //   columns:(19%, 27%, 27%, 27%),
  //   rows: (2.5em, auto),
  //   align: center + horizon,
  //   [Размер], [Одно ядро], [4 ядра], [8 ядер],
  kind: table,
  stp.longtable(
    columns:(19%, 27%, 27%, 1fr),
    rows:  (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Размер],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),

    [32], [0.007954], [0.454898], [0.622964],
    [64], [0.001022], [0.157984], [0.546454],
    [128], [0.001613], [0.195502], [0.31052],
    [256], [0.002925], [0.212372], [0.288239],
    [512], [0.00614], [0.249379], [0.299651],
    [1024], [0.013242], [0.187417], [0.821468],
    [2048], [0.036031], [0.186556], [0.501861],
    [4096], [0.062546], [0.213815], [0.368627],
    [8192], [0.13561], [0.249489], [0.37026],
    [16384], [0.293567], [0.317211], [0.451349],
    [32768], [0.67833], [0.511159], [0.554569],
    [65536], [1.58606], [0.96691], [0.804016],
    [131072], [3.45899], [1.59716], [1.54787],
    [262144], [6.94271], [4.83196], [3.51917],
    [524288], [15.8176], [5.63401], [5.2375],
    [1048576], [40.1054], [17.033], [9.12598],
    [2097152], [135.52], [95.2771], [73.1935],
    table.hline(stroke:none),
    [4194304], [319.344], [238.415], [204.893],
    [8388608], [695.518], [443.021], [437.013],
    [16777216], [1426.43], [983.963], [1039.93],
    [33554432], [3061.06], [2069.51], [2053.05],
  ),
) <smt_off_amd_raw>

Метрики #emph("AMD") без #emph("SMT") показывают существенное улучшение #emph("IPC") в многопоточном режиме и снижение процента промахов кэша.  Отключение #emph("SMT") устраняет конкуренцию за исполнительные устройства, декодеры инструкций и кэш первого уровня, позволяя каждому потоку использовать все ресурсы ядра монопольно. Соответствующие изменения в метриках производительности показаны в таблице @smt_off_amd_perf.

#figure(
  caption:[Замеры метрик на #emph("AMD Ryzen 7 5800H")],
  table(
    columns:(26%, 1fr, 1fr, 1fr),
    rows: (2.5em, auto),
    align: center + horizon,
    [Метрика], [Одно ядро], [4 ядра], [8 ядер],
    [IPC], [1.59], [0.69], [0.41],
    [Промахи кэша (%)], [6.02], [28.29], [37.74],
    [Промахи ветвлений (%)], [0.13], [0.14], [0.14],
  ),
) <smt_off_amd_perf>

Результаты #emph("Intel Core i5-12450H") без #emph("Hyper-Threading") демонстрируют иную динамику. Важно отметить, что #emph("Hyper-Threading") доступен только на #emph("P") ядрах, тогда как #emph("E") ядра изначально не поддерживают эту технологию.  При отключенном #emph("Hyper-Threading") наблюдается ухудшение производительности на больших данных: восьмипоточная конфигурация вынуждена использовать все #emph("P") и #emph("E") ядра, что приводит к гетерогенному выполнению. Производительные ядра завершают работу быстрее и простаивают на барьерах синхронизации, ожидая более медленные #emph("E") ядра. Данные по времени выполнения для этого сценария приведены в таблице @smt_off_intel_raw.

#figure(
  caption:[Замеры времени выполнения на #emph("Intel Core i5-12450H")],
  kind: table,
  stp.longtable(
    columns:(19%, 27%, 27%, 1fr),
    rows:  (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Размер],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),
 
  // table(
  //   columns:(19%, 27%, 27%, 27%),
  //   rows: (2.5em, auto),
  //   align: center + horizon,
  //   [Размер], [Одно ядро], [4 ядра], [8 ядер],
    [32], [0.010997], [0.813273], [0.870665],
    [64], [0.00199], [0.352655], [0.625475],
    [128], [0.003755], [0.290983], [0.49094],
    [256], [0.007266], [0.317632], [0.622206],
    [512], [0.014694], [0.394683], [0.415895],
    table.hline(stroke:none),
    [1024], [0.03285], [0.368615], [1.27804],
    [2048], [0.076268], [0.330625], [0.664094],
    [4096], [0.147757], [0.39088], [0.524475],
    [8192], [0.324351], [0.527037], [0.584163],
    [16384], [0.727194], [0.923695], [0.996862],
    [32768], [1.71755], [1.32323], [1.05719],
    [65536], [2.48678], [2.34384], [2.90096],
    [131072], [4.21892], [2.34555], [5.11337],
    [262144], [8.88698], [4.13068], [6.239],
    [524288], [20.0271], [7.94803], [12.6238],
    [1048576], [61.6581], [24.4118], [18.4065],
    [2097152], [141.617], [56.57], [48.4533],
    [4194304], [307.985], [126.102], [100.53],
    [8388608], [642.509], [267.714], [208.784],
    [16777216], [1346.7], [544.755], [444],
    [33554432], [2784.31], [1168.18], [932.592],
  ),
) <smt_off_intel_raw>

Метрики #emph("Intel") без #emph("Hyper-Threading") показывают существенный рост #emph("IPC") для #emph("P") ядрер, подтверждая эффективность монопольного использования ресурсов ядра. #emph("E") ядра демонстрируют #emph("IPC") около единицы, что отражает архитектурные ограничения микроархитектуры #emph("Gracemont").  Высокий процент промахов кэша на обоих типах ядер указывает на подсистему памяти как ключевой ограничивающий фактор. Сводка по метрикам производительности для режима с отключенным #emph("Hyper-Threading") находится в таблице @smt_off_intel_perf.


#figure(
  caption:[Замеры метрик на #emph("Intel Core i5-12450H")],
  // table(
  //   columns:(26%, 1fr, 1fr, 1fr),
  //   rows: (2.5em, auto),
  //   align: center + horizon,
  //   [Метрика], [Одно ядро], [4 ядра], [8 ядер],
  kind: table,
  stp.longtable(
    columns:(26%, 1fr, 1fr, 1fr),
    rows:  (2.5em, auto),

    align: center + horizon,

    table.header(

      repeat:true,
      align(center)[Метрика],
      align(center)[Одно ядро],
      align(center)[4 ядра],
      align(center)[8 ядер],
      table.hline(stroke:black),
    ),
 

    [IPC], [1.82 / -], [5.41 / -], [7.29 / 1.00],
    [Промахи кэша (%)], [69.54 / -], [51.18 / -], [66.53 / 75.47],
    [Промахи ветвлений (%)], [0.10 / -], [0.12 / -], [0.11 / 0.17],
  ),
) <smt_off_intel_perf>

Сравнение результатов двух процессоров при отключенных технологиях многопоточности демонстрирует изменение баланса сил между платформами. В однопоточном режиме #emph("AMD") сохраняет преимущество на малых размерах данных, однако разрыв сокращается по сравнению с режимом с включенным #emph("SMT"). При использовании четырёх ядер #emph("Intel") показывает худшие результаты на малых данных из-за больших накладных расходов, но на средних и больших размерах демонстрирует преимущество благодаря более высокой производительности #emph("P") ядер. 

Наиболее интересная картина наблюдается в восьмиядерной конфигурации. #emph("AMD") показывает стабильные результаты, сопоставимые с режимом с включенным #emph("SMT"), тогда как #emph("Intel") демонстрирует заметное падение производительности по сравнению с режимом с #emph("Hyper-Threading"). Это объясняется тем, что при отключенном #emph("Hyper-Threading") #emph("Intel") вынужден задействовать менее производительные #emph("E") ядра, которые становятся узким местом системы. Тем не менее, на больших размерах данных #emph("Intel") по-прежнему опережает #emph("AMD"), хотя разрыв существенно сокращается — примерно до двукратного преимущества вместо более чем двукратного при включенном #emph("Hyper-Threading").

По метрикам производительности отключение технологий многопоточности положительно сказывается на обеих платформах: #emph("IPC") возрастает, а процент промахов кэша снижается. Однако #emph("AMD") получает больший относительный выигрыш от отключения #emph("SMT"), тогда как #emph("Intel") теряет в абсолютной производительности из-за необходимости использования гетерогенных ядер.

== Результаты тестирования на iGPU

Сравнение производительности встроенных графических ускорителей (#emph("iGPU")) процессоров #emph("AMD") и #emph("Intel") на задаче БПФ выявляет сложную и нелинейную зависимость производительности от размера входных данных. Сравнительные результаты тестирования представлены в таблице @igpu_raw.

#figure(
  caption:[Замеры времени выполнения на #emph("iGPU")],
  kind: table,
  stp.longtable(
    columns:(34%, 33%, 1fr),
    rows: (2.5em, auto),
    align: center + horizon,
    table.header(
      repeat:true,
      align(center)[Размер],
      align(center)[#emph("AMD Radeon RX Vega 8")],
      align(center)[#emph("Intel Iris Xe Graphics")],
      table.hline(stroke:black),
    ),
    [32], [0.0111], [0.032654],
    [64], [0.009496], [0.037497],
    [128], [0.01026], [0.034422],
    [256], [0.045364], [0.039265],
    [512], [0.051054], [0.054421],
    [1024], [0.018754], [0.049995],
    [2048], [0.02192], [0.056352],
    [4096], [0.024006], [0.065255],
    [8192], [0.033823], [0.082076],
    [16384], [0.057185], [0.098327],
    [32768], [0.540957], [0.137391],
    table.hline(stroke:none),
    [65536], [0.641145], [0.279056],
    [131072], [0.883801], [0.42114],
    [262144], [2.28955], [0.743377],
    [524288], [4.03693], [1.72015],
    [1048576], [8.58995], [4.59515],
    [2097152], [17.7182], [22.2319],
    [4194304], [36.9868], [42.414],
    [8388608], [78.3595], [86.3744],
    [16777216], [162.237], [118.307],
  ),
) <igpu_raw>

Анализ результатов показывает, что ни одно из интегрированных решений не имеет абсолютного преимущества. На малых размерах данных (до 16К) #emph("iGPU") от #emph("AMD") демонстрирует более низкое время выполнения. Это может быть связано с меньшими накладными расходами на запуск #emph("OpenCL") ядра и передачу данных.

Однако при переходе к средним размерам (от 32К до 1М) наблюдается инверсия производительности: #emph("Intel Iris Xe") показывает значительно лучшие результаты, опережая конкурента в полтора раза. Вероятно, на этих размерах данных архитектура #emph("Intel") с большим количеством исполнительных блоков (#emph("Execution Units")) и более эффективной работой с локальной памятью обеспечивает существенный прирост производительности.

При дальнейшем увеличении массива данных (от 2М до 8М) #emph("AMD") вновь выходит вперед. Это может указывать на то, что при работе с объёмами, значительно превышающими кэши #emph("GPU"), узким местом становится пропускная способность системной памяти, и в этом аспекте архитектура #emph("AMD") оказывается более сбалансированной. Наконец, на максимальном размере в 16М #emph("Intel") снова показывает лучшее время, что может быть следствием совокупности факторов, включая чистую вычислительную мощность, которая на предельных нагрузках перевешивает недостатки в работе с памятью.

