= Теоретическое обоснование разработки программного продукта

== Обоснование необходимости разработки

Для объективной оценки производительности современных центральных процессоров недостаточно простого сопоставления их формальных технических характеристик. Различия в архитектуре, объеме кэш-памяти и реализации технологий многопоточности требуют проведения практических испытаний в реалистичных сценариях. В связи с этим для детального и объективного сравнительного анализа производительности двух популярных мобильных процессоров, #emph("Intel Core i5-12450H") и #emph("AMD Ryzen 7 5800H"), необходимо использовать специализированное программное обеспечение. Стандартные бенчмарки, давая общее представление, не позволяют углубленно изучить поведение процессоров в специфических, вычислительно интенсивных задачах.

Для этих целей в качестве тестовой нагрузки был выбран алгоритм быстрого преобразования Фурье (БПФ). БПФ является фундаментальной операцией, находящей широкое применение в цифровой обработке сигналов, анализе изображений, решении дифференциальных уравнений и многих других научных и инженерных областях. Эффективность его выполнения напрямую зависит от ключевых архитектурных особенностей процессора: скорости выполнения операций с плавающей запятой, пропускной способности подсистемы памяти и эффективности работы кэша. Это делает БПФ идеальным инструментом для выявления сильных и слабых сторон процессорных архитектур.

Разработка собственного приложения позволяет создать полностью контролируемую и воспроизводимую среду для тестирования, свободную от влияния стороннего программного обеспечения. Программа предоставит возможность точно контролировать количество вычислительных потоков и привязывать их к конкретным физическим ядрам (#emph("CPU affinity")). Такой гранулярный контроль имеет ключевое значение для данного исследования, поскольку позволит детально изучить масштабируемость производительности, сравнить эффективность технологии #emph("SMT") от #emph("AMD") и гибридного подхода #emph("Intel"), а также изолированно измерить производительность производительных (#emph("P-cores")) и энергоэффективных (#emph("E-cores")) ядер.

Таким образом, создание специализированного программного продукта является не просто технической задачей, а необходимым методологическим инструментом. Он позволит получить глубокие и детализированные данные, необходимые для того, чтобы выйти за рамки поверхностного сравнения и сделать обоснованные выводы об архитектурных преимуществах и недостатках исследуемых процессоров в контексте параллельных научных вычислений.

== Технологии программирования, используемые для решения поставленных задач

Для реализации программного продукта, направленного на исследование производительности центральных процессоров в вычислительно интенсивных задачах, был выбран язык программирования #emph("C++") с использованием стандарта #emph("C++20") @cpp20_standard.

Данный выбор обоснован ключевыми факторами, связанными с эффективностью и возможностями, необходимыми для реализации алгоритма быстрого преобразования Фурье (#emph("БПФ")). #emph("C++") обеспечивает высочайшую производительность благодаря генерации кода, близкого к машинным инструкциям, и отсутствию фоновых процессов, таких как сборка мусора, что позволяет проводить "чистые" замеры производительности процессора. Гибкость управления памятью в #emph("C++") также играет ключевую роль. Язык позволяет организовывать данные в памяти таким образом, чтобы обеспечить их локальность и последовательный доступ. Для алгоритмов, подобных #emph("БПФ"), где производятся многочисленные "баттерфляй"-преобразования, такая оптимизация работы с кэш-памятью процессора является определяющим фактором для достижения высокой производительности.

Важной частью технологического стека является инструментарий для сборки и компиляции. В качестве системы сборки используется кросс-платформенный инструмент #emph("CMake") @cmake_doc, который автоматизирует процесс компиляции исходного кода в исполняемый файл. #emph("CMake") обеспечивает переносимость проекта между различными операционными системами и средами разработки, а также управляет зависимостями, такими как тестовый фреймворк #emph("Google Test"), что гарантирует воспроизводимость результатов. Исходный код преобразуется в машинный с помощью одного из современных оптимизирующих компиляторов, например, #emph("GCC") @gcc_site. Этот компилятор производит глубокий анализ кода и применяет множество техник оптимизации для генерации максимально эффективного исполняемого файла, что напрямую влияет на точность и достоверность полученных в ходе тестирования данных.

Для реализации ключевых аспектов программы были задействованы специализированные стандартные библиотеки #emph("C++").

Библиотека #emph("<thread>") @cpp_thread предоставляет набор инструментов для создания и управления потоками выполнения в рамках одного процесса. В данном проекте она является основой для реализации многопоточного режима тестирования. С ее помощью основная вычислительная задача распределяется между несколькими потоками, которые операционная система может исполнять параллельно на разных физических или логических ядрах процессора. Это позволяет в полной мере загрузить многоядерные архитектуры и собрать данные об эффективности параллельной обработки и масштабируемости производительности исследуемых процессоров.

Библиотека #emph("<chrono>") @cpp_chrono используется для точного измерения временных интервалов. Она предоставляет доступ к различным системным часам, включая #emph("std::chrono::high_resolution_clock"), которые обеспечивают максимально возможную точность измерений. В контексте тестирования производительности, где время выполнения операций может составлять миллисекунды или даже микросекунды, использование часов высокого разрешения является обязательным условием для получения достоверных и воспроизводимых результатов. Данная библиотека позволяет с высокой точностью фиксировать время начала и окончания вычислений, что является основой для всех последующих оценок производительности.

Таким образом, выбор языка #emph("C++") в сочетании с современной системой сборки #emph("CMake") и мощными стандартными библиотеками, такими как #emph("<thread>") и #emph("<chrono>"), формирует надежную технологическую основу. Этот стек технологий позволяет разработать специализированное программное обеспечение, способное с высокой точностью и эффективностью проводить измерения производительности, что является необходимым условием для объективного сравнительного анализа процессорных архитектур.

== Связь архитектуры вычислительной системы с разрабатываемым программным обеспечением

Архитектурные особенности выбранных процессоров оказывают прямое и определяющее влияние на проектирование и реализацию программного обеспечения. Понимание этих взаимосвязей является ключевым для создания эффективного тестового приложения, способного в полной мере раскрыть потенциал каждой архитектуры и выявить их характерные особенности.

Разработанное приложение предоставляет возможность изолированного тестирования как производительных (#emph("P-cores")), так и энергоэффективных (#emph("E-cores")) ядер на #emph("Intel Core i5-12450H"), позволяя оценить их вклад в общую производительность и раскрыть эффективность аппаратного планировщика #emph("Intel Thread Director"). Для #emph("AMD Ryzen 7 5800H") с его симметричной структурой из восьми одинаковых ядер программа позволяет тестирование с произвольным количеством рабочих потоков, что обеспечивает оценку линейности масштабирования производительности.

Реализация алгоритма #emph("БПФ") в контексте данных архитектур требует особого внимания к организации работы с данными. Объём кэш-памяти различных уровней напрямую влияет на эффективность алгоритма: #emph("AMD Ryzen 7 5800H") обладает 16 МБ объединённого кэша #emph("L3"), в то время как #emph("Intel Core i5-12450H") — 12 МБ. Для алгоритмов, оперирующих большими объёмами данных и характеризующихся сложными паттернами доступа к памяти, эта разница может быть значимой. Правильная организация циклов, выравнивание данных в памяти и минимизация конфликтов кэша позволяют снизить количество промахов кэша и повысить пропускную способность доступа к памяти на обеих платформах.

Флаги компиляции #emph("-O3") и #emph("-march=native") являются решающими для достижения максимальной производительности. Флаг #emph("-march=native") инструктирует компилятор #emph("GCC") использовать все доступные инструкции целевого процессора, включая расширения #emph("SIMD"). Для #emph("AMD Ryzen 7 5800H") это означает использование инструкций #emph("AVX2"), а для #emph("Intel Core i5-12450H") — как #emph("AVX2"), так и потенциально расширенные наборы инструкций, доступные на платформе #emph("Alder Lake"). Автоматическая векторизация циклов компилятором позволяет обрабатывать несколько элементов данных в рамках одной инструкции, что существенно ускоряет выполнение барочка-трансформаций в #emph("БПФ").

Микроархитектурные различия учитываются при проектировании приложения. #emph("Zen 3") с её фокусом на повышение #emph("IPC") (инструкций за такт) лучше справляется с задачами, требующими выполнения большого количества независимых инструкций в единицу времени. Барочка-трансформация в #emph("БПФ") содержит множество независимых арифметических операций, что делает эту архитектуру особенно подходящей для данного алгоритма. Архитектура #emph("Alder Lake") ориентирована на оптимизацию однопоточной производительности производительных ядер, что требует учёта при распределении нагрузки между различными типами ядер.

Разработанное приложение включает возможность запуска алгоритма с переменным количеством потоков, привязку потоков к конкретным физическим ядрам через механизм #emph("CPU affinity"), использование современных инструкций #emph("SIMD") для векторизации операций над комплексными числами и минимизацию системных издержек за счёт минимальной конфигурации #emph("Arch Linux"). Такой подход позволяет создать инструмент, способный максимально объективно и детально оценить производительность исследуемых архитектур в контексте вычислительно интенсивной задачи, не искажённую влиянием системных процессов или неправильной оптимизации компилятора.
